/*
    This file is part of Nori, a simple educational ray tracer

    Copyright (c) 2015 by Wenzel Jakob

    Nori is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License Version 3
    as published by the Free Software Foundation.

    Nori is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#include <nori/bitmap.h>
#include <ImfInputFile.h>
#include <ImfOutputFile.h>
#include <ImfChannelList.h>
#include <ImfStringAttribute.h>
#include <ImfVersion.h>
#include <ImfIO.h>

#include <memory>
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image_write.h>

NORI_NAMESPACE_BEGIN

Bitmap::Bitmap(const std::string &filename) {
    Imf::InputFile file(filename.c_str());
    const Imf::Header &header = file.header();
    const Imf::ChannelList &channels = header.channels();

    Imath::Box2i dw = file.header().dataWindow();
    resize(dw.max.y - dw.min.y + 1, dw.max.x - dw.min.x + 1);

    cout << "Reading a " << cols() << "x" << rows() << " OpenEXR file from \""
         << filename << "\"" << endl;

    const char *ch_r = nullptr, *ch_g = nullptr, *ch_b = nullptr;
    for (Imf::ChannelList::ConstIterator it = channels.begin(); it != channels.end(); ++it) {
        std::string name = toLower(it.name());

        if (it.channel().xSampling != 1 || it.channel().ySampling != 1) {
            /* Sub-sampled layers are not supported */
            continue;
        }

        if (!ch_r && (name == "r" || name == "red" || 
                endsWith(name, ".r") || endsWith(name, ".red"))) {
            ch_r = it.name();
        } else if (!ch_g && (name == "g" || name == "green" || 
                endsWith(name, ".g") || endsWith(name, ".green"))) {
            ch_g = it.name();
        } else if (!ch_b && (name == "b" || name == "blue" || 
                endsWith(name, ".b") || endsWith(name, ".blue"))) {
            ch_b = it.name();
        }
    }

    if (!ch_r || !ch_g || !ch_b)
        throw NoriException("This is not a standard RGB OpenEXR file!");

    size_t compStride = sizeof(float),
           pixelStride = 3 * compStride,
           rowStride = pixelStride * cols();

    char *ptr = reinterpret_cast<char *>(data());

    Imf::FrameBuffer frameBuffer;
    frameBuffer.insert(ch_r, Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert(ch_g, Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert(ch_b, Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); 
    file.setFrameBuffer(frameBuffer);
    file.readPixels(dw.min.y, dw.max.y);
}

void Bitmap::save(const std::string &filename) {
    cout << "Writing a " << cols() << "x" << rows() 
         << " OpenEXR file to \"" << filename << "\"" << endl;

    Imf::Header header((int) cols(), (int) rows());
    header.insert("comments", Imf::StringAttribute("Generated by Nori"));

    Imf::ChannelList &channels = header.channels();
    channels.insert("R", Imf::Channel(Imf::FLOAT));
    channels.insert("G", Imf::Channel(Imf::FLOAT));
    channels.insert("B", Imf::Channel(Imf::FLOAT));

    Imf::FrameBuffer frameBuffer;
    size_t compStride = sizeof(float),
           pixelStride = 3 * compStride,
           rowStride = pixelStride * cols();

    char *ptr = reinterpret_cast<char *>(data());
    frameBuffer.insert("R", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert("G", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert("B", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); 

    Imf::OutputFile file(filename.c_str(), header);
    file.setFrameBuffer(frameBuffer);
    file.writePixels((int) rows());
}

static float GammaCorrect(float value) {
    if (value <= 0.0031308f) return 12.92f * value;
    return 1.055f * std::pow(value, 1.f/2.4f) - 0.055f;
}
static float Clamp(float val, float low, float high) {
    if (val < low)
        return low;
    else if (val > high)
        return high;
    else
        return val;
}

void Bitmap::saveToLDR(const std::string &filename) {
    cout << "Writing a " << cols() << "x" << rows()
    << " PNG file to \"" << filename << "\"" << endl;

    std::unique_ptr<uint8_t[]> rgb8(new uint8_t[3 * cols() * rows()]);
    uint8_t *dst = rgb8.get();
    for (int y = 0; y < rows(); ++y) {
        for (int x = 0; x < cols(); ++x) {
#define TO_BYTE(v) (uint8_t) Clamp(255.f * GammaCorrect(v) + 0.5f, 0.f, 255.f)
            dst[0] = TO_BYTE(coeff(y,x).r());
            dst[1] = TO_BYTE(coeff(y,x).g());
            dst[2] = TO_BYTE(coeff(y,x).b());
#undef TO_BYTE
            dst += 3;
        }
    }
    stbi_write_png(filename.c_str(),cols(),rows(),3,rgb8.get(),3*cols());
}


// Texture file
Texture::Texture(const std::string& filename) : Bitmap(filename)
{
	m_width = static_cast<int>(Base::cols());
	m_height = static_cast<int>(Base::rows());
	m_filename = filename;
}

Color3f Texture::getval(float x, float y) const
{
	// Assuming x and y to be 0 - 1 space
	// if not clamp it
	// for now
	x = Clamp(x, 0.0f, 1.0f);
	y = Clamp(y, 0.0f, 1.0f);

	// for now return nearest neighbour
	int pixel_x = static_cast<int>(floor(x * m_width));
	int pixel_y = static_cast<int>(floor(y * m_height));
	
	if (pixel_x >= m_width) pixel_x = m_width - 2;
	if (pixel_y >= m_height) pixel_y = m_height - 2;

	return Base::operator()(pixel_y, pixel_x);
	//return bilerp(x, y);
}

Color3f Texture::bilerp(float x, float y) const
{
	// find the nearest four corners
	int pixel_x = static_cast<int>(floor(x * m_width));
	int pixel_y = static_cast<int>(floor(y * m_height));

 	float s = x * m_width - pixel_x;
	float t = y * m_height - pixel_y;

	if (pixel_x == m_width) pixel_x = m_width - 1;
	if (pixel_y == m_height) pixel_y = m_height - 1;

	int x_1 = pixel_x >= m_width - 1 ? 0 : pixel_x + 1;
	int y_1 = pixel_y >= m_height - 1 ? 0 : pixel_y + 1;

	Point2i x00(pixel_x, pixel_y);
	Point2i x01(x_1, pixel_y);
	Point2i x10(pixel_x, y_1);
	Point2i x11(x_1, y_1);

	Color3f c00 = Base::operator()(x00.x(), x00.y());
	Color3f c01 = Base::operator()(x01.x(), x01.y());
	Color3f c10 = Base::operator()(x10.x(), x10.y());
	Color3f c11 = Base::operator()(x11.x(), x11.y());

	// bilerp it
	return c00 * (1.0f - s) * (1.0f - t) + c01 * (1.0f - s) * t + c10 * s * (1.0f - t) + c11 * s * t;
}

Color3f Texture::trilerp(float x, float y) const
{
	return 0.0f;
}

NORI_NAMESPACE_END
